
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\pixi\\containers\\canvasLayers\\sightLayer.d.ts",
      "/**\n * The Sight Layer which implements dynamic vision, lighting, and fog of war\n * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.\n * @see PointSource\n *\n * @example <caption>The sightRefresh hook</caption>\n * ```typescript\n * Hooks.on(\"sightRefresh\", layer => {});\n * ```\n */\ndeclare class SightLayer extends CanvasLayer {\n  constructor();\n\n  /**\n   * Fog of War data object\n   * @defaultValue\n   * ```\n   * {\n   *   _id: null,\n   *   explored: null,\n   *   positions: {}\n   * }\n   * ```\n   */\n  fogData: {\n    _id: string | null;\n    explored: boolean | string | null;\n    positions: Record<`${number}_${number}`, { radius: number; limit: number }>;\n    scene?: string;\n    timestamp?: number;\n    user?: string;\n  };\n\n  /**\n   * A Collection of vision sources which are currently active within the rendered Scene.\n   */\n  sources: foundry.utils.Collection<PointSource>;\n\n  /**\n   * The canonical line-of-sight polygon which defines current Token visibility.\n   */\n  los: PIXI.Graphics;\n\n  /**\n   * The blur distance for soft shadows\n   * @defaultValue `0`\n   */\n  protected _blurDistance: number;\n\n  /**\n   * A status flag for whether the layer initialization workflow has succeeded\n   * @defaultValue `false`\n   */\n  protected _initialized: boolean;\n\n  /**\n   * The downscaling resolution used for the saved fog texture\n   * @defaultValue `1`\n   */\n  protected _fogResolution: number;\n\n  /**\n   * A pool of fog of war exploration containers that can be recycled\n   * @defaultValue `[]`\n   */\n  protected _visionPool: PIXI.Container[];\n\n  /**\n   * Track whether fog of war exploration has been updated and required saving\n   * @defaultValue `false`\n   */\n  protected _fogUpdated: boolean;\n\n  /**\n   * Track the number of moves which have updated fog of war\n   * @defaultValue `0`\n   */\n  protected _fogUpdates: number;\n\n  /**\n   * A debounced function to save fog of war exploration once a stream of updates have stopped\n   */\n  debounceSaveFog: (...args: Parameters<this['update']>) => void;\n\n  /**\n   * @override\n   * @defaultValue `mergeObject(super.layerOptions, { zIndex: 210 })`\n   */\n  static get layerOptions(): CanvasLayer.LayerOptions;\n\n  /**\n   * Does the currently viewed Scene support Token field of vision?\n   */\n  get tokenVision(): boolean;\n\n  /**\n   * Does the currently viewed Scene support fog of war exploration?\n   */\n  get fogExploration(): boolean;\n\n  /** @override */\n  tearDown(): Promise<void>;\n\n  /**\n   * Initialize the Sight Layer. Initialization has the following hierarchical workflow:\n   *\n   * Initialize Layer (reset entire layer)\n   *  InitializeLights (used to reset all lights)\n   *    UpdateLight (update a single light)\n   *  InitializeTokens (reset all tokens)\n   *    UpdateToken (update a single token)\n   *  Initialize Fog (reset FOW state)\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Initialize fog of war - resetting it when switching scenes or re-drawing the canvas\n   */\n  initializeFog(): Promise<void>;\n\n  /** @override */\n  draw(): Promise<this>;\n\n  /**\n   * Draw the fog of war exploration container\n   */\n  protected _drawFogContainer(): PIXI.Container;\n\n  /**\n   * Construct a vision container that is used to render a single view position.\n   * These containers are placed into the _visionPool and recycled as needed.\n   */\n  protected _createVisionContainer(): PIXI.Container;\n\n  /**\n   * Obtain a vision container from the recycling pool, or create one if no container exists.\n   * Assign the container as the current fog exploration and the current LOS polygon.\n   */\n  protected _getVisionContainer(): PIXI.Container;\n\n  /**\n   * Return a vision container back to the pool, recycling it for future use.\n   * @param c - The container to recycle\n   */\n  protected _recycleVisionContainer(c: PIXI.Container): void;\n\n  /**\n   * Update the display of the sight layer.\n   * Organize sources into rendering queues and draw lighting containers for each source\n   *\n   * @param forceUpdateFog - Always update the Fog exploration progress for this update\n   *                         (default: `false`)\n   * @param noUpdateFog    - Never update the Fog exploration progress for this update\n   *                         (default: `false`)\n   */\n  refresh({ forceUpdateFog, noUpdateFog }?: { forceUpdateFog?: boolean; noUpdateFog?: boolean }): void;\n\n  /* -------------------------------------------- */\n\n  /**\n   * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon\n   * These assets should only be displayed if they are visible given the current player's field of view\n   */\n  restrictVisibility(): void;\n\n  /**\n   * Once a new Fog of War location is explored, composite the explored container with the current staging sprite\n   * Save that staging Sprite as the rendered fog exploration and swap it out for a fresh staging texture\n   * Do all this asynchronously, so it doesn't block token movement animation since this takes some extra time\n   */\n  protected commitFog(): Promise<void>;\n\n  /**\n   * Load existing fog of war data from local storage and populate the initial exploration sprite\n   */\n  loadFog(): Promise<PIXI.Texture>;\n\n  /**\n   * Dispatch a request to reset the fog of war exploration status for all users within this Scene.\n   * Once the server has deleted existing FogExploration documents, the _onResetFog handler will re-draw the canvas.\n   */\n  resetFog(): Promise<Canvas | undefined>;\n\n  /**\n   * Save Fog of War exploration data to a base64 string to the FogExploration document in the database.\n   * Assumes that the fog exploration has already been rendered as fog.rendered.texture.\n   */\n  protected saveFog(): Promise<any>; // TODO: Type when SocketInterface is done\n\n  /**\n   * Update the fog layer when a player token reaches a board position which was not previously explored\n   * @param source - The vision source for which the fog layer should update\n   * @param force  - Force fog to be updated even if the location is already explored\n   *                 (default: `false`)\n   */\n  updateFog(source: PointSource, force?: boolean): void;\n\n  /**\n   * Choose an adaptive fog rendering resolution which downscales the saved fog textures for larger dimension Scenes\n   */\n  protected _configureFogResolution(): number;\n\n  /**\n   * Trigger a server-side update (or creation) of fog exploration status for a certain Scene\n   */\n  protected _createOrUpdateFogExploration(fogData: this['fogData']): Promise<any>; // TODO: Type when SocketInterface is done\n\n  /**\n   * If fog of war data is reset from the server, re-draw the canvas\n   * @param resetData - Fog reset data sent by the server\n   */\n  protected _onResetFog(resetData: { reset: boolean; scene: string }): Promise<Canvas | undefined>;\n\n  /**\n   * Compute line-of-sight and field-of-vision polygons for a given origin position and visibility radius.\n   * The line-of-sight polygon defines the unrestricted area of visibility for the source.\n   * The field-of-vision polygon defines the restricted area of visibility for the source.\n   * @param origin       - An point with coordinates x and y representing the origin of the test\n   * @param radius       - A distance in canvas pixels which reflects the visible range\n   * @param angle        - An optional limited angle of emission with which to restrict polygons\n   *                       (default: `360`)\n   * @param density      - The desired radial density of emission for rays, in degrees\n   *                       (default: `6`)\n   * @param rotation     - (default: `0`)\n   * @param unrestricted - Compute sight that is unrestricted by walls\n   *                       (default: `false`)\n   * @returns The computed rays and polygons\n   */\n  static computeSight(\n    origin: Point,\n    radius: number,\n    {\n      angle,\n      density,\n      rotation,\n      unrestricted\n    }?: { angle?: number; density?: number; rotation?: number; unrestricted?: boolean }\n  ): { rays: Ray[]; los: PIXI.Polygon; fov: PIXI.Polygon };\n\n  /* -------------------------------------------- */\n\n  /**\n   * A helper method responsible for casting rays at wall endpoints.\n   * Rays are restricted by limiting angles.\n   *\n   * @param x          - The origin x-coordinate\n   * @param y          - The origin y-coordinate\n   * @param distance   - The ray distance\n   * @param density    - The desired radial density\n   *                     (default: `4`)\n   * @param endpoints  - An array of endpoints to target\n   * @param limitAngle - Whether the rays should be cast subject to a limited angle of emission\n   *                     (default: `false`)\n   * @param aMin       - The minimum bounding angle\n   * @param aMax       - The maximum bounding angle\n   *\n   * @returns An array of Ray objects\n   */\n  protected static _castRays(\n    x: number,\n    y: number,\n    distance: number,\n    {\n      density,\n      endpoints,\n      limitAngle,\n      aMin,\n      aMax\n    }: { density?: number; endpoints: PointArray[]; limitAngle: boolean; aMin: number; aMax: number }\n  ): Ray[];\n\n  /**\n   * Test whether a point on the Canvas is visible based on the current vision and LOS polygons\n   * @param point     - The point in space to test, an object with coordiantes x and y.\n   * @param tolerance - A numeric radial offset which allows for a non-exact match. For example, if\n   *                    tolerance is 2 then the test will pass if the point is within 2px of a vision\n   *                    polygon.\n   *                    (default: `2`)\n   * @param object    - An optional reference to the object whose visibility is being tested\n   *                    (default: `null`)\n   * @returns Whether the point is currently visible.\n   */\n  testVisibility(\n    point: Point,\n    { tolerance, object }?: { tolerance?: number; object?: PIXI.DisplayObject | null }\n  ): boolean;\n\n  /**\n   * Normalize an angle to ensure it is baselined to be the smallest angle that is greater than a minimum.\n   * @param aMin  - The lower-bound minimum angle\n   * @param angle - The angle to adjust\n   * @returns The adjusted angle which is greater than or equal to aMin.\n   */\n  protected static _adjustRayAngle(aMin: number, angle: number): number;\n\n  /**\n   * Visualize the sight layer to understand algorithm performance.\n   * @param bounds    - The initial rectangular bounds of the vision check\n   * @param endpoints - The wall endpoints being tested\n   * @param rays      - The array of cast vision Rays\n   * @param los       - The resulting line-of-sight polygon\n   * @param fov       - The resulting field-of-vision polygon\n   */\n  protected static _visualizeSight(\n    bounds: Rectangle,\n    endpoints: PointArray[],\n    rays: Ray[],\n    los: PIXI.Polygon,\n    fov: PIXI.Polygon\n  ): void;\n\n  /**\n   * @deprecated since 0.7.3\n   * @see {@link Canvas#initializeSources}\n   */\n  initializeTokens({ defer }?: { defer?: boolean }): void;\n\n  /**\n   * @deprecated since 0.7.3\n   * @see {@link SightLayer#refresh}\n   */\n  update(options?: { forceUpdateFog?: boolean; noUpdateFog?: boolean }): void;\n\n  /**\n   * @deprecated since 0.7.3\n   * @see {@link Token#updateSource}\n   */\n  updateToken(token: Token, options: { defer?: boolean; deleted?: boolean; noUpdateFog?: boolean }): void;\n\n  /**\n   * @deprecated since 0.7.3\n   * @see {@link AmbientLight#updateSource}\n   */\n  updateLight(light: AmbientLight, options: { defer: boolean; deleted: boolean }): boolean | void | null;\n\n  /**\n   * Define the threshold value for the number of distinct Wall endpoints.\n   * Below this threshold, exact vision computation is used by casting a Ray at every endpoint.\n   * Above this threshold, approximate vision computation is used by culling to only nearby endpoints.\n   * @defaultValue `500`\n   */\n  static EXACT_VISION_THRESHOLD: number;\n\n  /**\n   * Define the number of positions that are explored before a set of fog updates are pushed to the server.\n   * @defaultValue `10`\n   */\n  static FOG_COMMIT_THRESHOLD: number;\n}\n"
    ]
  