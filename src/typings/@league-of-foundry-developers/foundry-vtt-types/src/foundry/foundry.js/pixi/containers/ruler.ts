
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\pixi\\containers\\ruler.d.ts",
      "/**\n * The Ruler - used to measure distances and trigger movements\n */\ndeclare class Ruler extends PIXI.Container {\n  /*\n   * @param user  - The User for whom to construct the Ruler instance\n   * @param color - The color for the ruler\n   *                (Default value: The user's color or `0x42f4e2`)\n   */\n  constructor(user?: User, { color }?: { color?: number | null });\n\n  /**\n   * Record the User which this Ruler references\n   */\n  user: User;\n\n  /**\n   * The ruler name - used to differentiate between players\n   */\n  name: string;\n\n  /**\n   * The ruler color - by default the color of the active user\n   */\n  color: number;\n\n  /**\n   * This Array tracks individual waypoints along the ruler's measured path.\n   * The first waypoint is always the origin of the route.\n   */\n  waypoints: PIXI.Point[];\n\n  /**\n   * The current destination point at the end of the measurement\n   */\n  destination: PIXI.Point | null;\n\n  /**\n   * The Ruler element is a Graphics instance which draws the line and points of the measured path\n   */\n  ruler: PIXI.Graphics;\n\n  /**\n   * The Labels element is a Container of Text elements which label the measured path\n   */\n  labels: PIXI.Container;\n\n  /**\n   * Track the current measurement state\n   * @see Ruler.STATES\n   */\n  protected _state: ValueOf<typeof Ruler['STATES']>;\n\n  /**\n   * Is the Ruler being actively used to measure distance?\n   */\n  get active(): boolean;\n\n  /**\n   * Measure the distance between two points and render the ruler UI to illustrate it\n   * @param destination - The destination point to which to measure\n   * @param gridSpaces  - Restrict measurement only to grid spaces\n   *                      (default: `true`)\n   */\n  measure(\n    destination: Point,\n    { gridSpaces }?: { gridSpaces?: boolean }\n  ): {\n    ray: Ray;\n    label: PIXI.DisplayObject;\n  }[];\n\n  /**\n   * Get the text label for a segment of the measured path\n   * @param isTotal - (unused)\n   */\n  protected _getSegmentLabel(segmentDistance: number, totalDistance: number, isTotal?: boolean): string;\n\n  /**\n   * Highlight the measurement required to complete the move in the minimum number of discrete spaces\n   */\n  protected _highlightMeasurement(ray: Ray): void;\n\n  /**\n   * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler\n   *\n   * @returns An indicator for whether a token was successfully moved or not. If True the event should be\n   *          prevented from propagating further, if False it should move on to other handlers.\n   * @remarks This will never actually return `true`\n   */\n  moveToken(): Promise<boolean | undefined>;\n\n  /**\n   * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler\n   */\n  protected _getMovementToken(): Token | null | undefined;\n\n  /**\n   * A helper method to return an Array of Ray objects constructed from the waypoints of the measurement\n   * @param waypoints   - An Array of waypoint `{x, y}` Objects\n   * @param destination - An optional destination point to append to the existing waypoints\n   * @returns An Array of Ray objects which represent the segemnts of the waypoint path\n   */\n  protected _getRaysFromWaypoints(waypoints: Point[], destination?: Point): Ray[];\n\n  /**\n   * Clear display of the current Ruler\n   */\n  clear(): void;\n\n  /**\n   * Handle the beginning of a new Ruler measurement workflow\n   * @see Canvas._onDragLeftStart\n   */\n  protected _onDragStart(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle left-click events on the Canvas during Ruler measurement.\n   * @see Canvas._onClickLeft\n   */\n  protected _onClickLeft(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle right-click events on the Canvas during Ruler measurement.\n   * @see Canvas._onClickRight\n   */\n  protected _onClickRight(event: PIXI.InteractionEvent): boolean | void;\n\n  /**\n   * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.\n   * @see Canvas._onDragLeftMove\n   */\n  protected _onMouseMove(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Conclude a Ruler measurement workflow by releasing the left-mouse button.\n   * @see Canvas._onDragLeftDrop\n   */\n  protected _onMouseUp(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle the addition of a new waypoint in the Ruler measurement path\n   */\n  protected _addWaypoint(point: Point): void;\n\n  /**\n   * Handle the removal of a waypoint in the Ruler measurement path\n   * @param point - The current cursor position to snap to\n   * @param snap  - Snap exactly to grid spaces?\n   *                (default: `true`)\n   */\n  protected _removeWaypoint(point: Point, { snap }?: { snap?: boolean }): void;\n\n  /**\n   * Handle the conclusion of a Ruler measurement workflow\n   */\n  protected _endMeasurement(): void;\n\n  toJSON(): {\n    class: 'Ruler';\n    name: string;\n    waypoints: Ruler['waypoints'];\n    destination: Ruler['destination'];\n    _state: Ruler['_state'];\n  };\n\n  /**\n   * Update a Ruler instance using data provided through the cursor activity socket\n   * @param data - Ruler data with which to update the display\n   */\n  update(data: {\n    class: 'Ruler';\n    waypoints: Ruler['waypoints'];\n    destination: Ruler['destination'];\n    _state: Ruler['_state'];\n  }): void;\n\n  /**\n   * The possible Ruler measurement states which can occur\n   */\n  static STATES: {\n    INACTIVE: 0;\n    STARTING: 1;\n    MEASURING: 2;\n    MOVING: 3;\n  };\n}\n"
    ]
  