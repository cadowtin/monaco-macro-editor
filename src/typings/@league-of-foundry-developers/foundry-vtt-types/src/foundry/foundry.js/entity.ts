
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\entity.d.ts",
      "/**\n * An abstract class pattern for all primary data entities within the Foundry VTT Framework. An entity represents a\n * primary data concept, for example: Actor, Item, Scene, or ChatMessage. Each Entity type in Foundry Virtual\n * Tabletop extends this base Entity class which ensures similar behavior and workflow across all entity types.\n *\n * Documentation for this class is provided for reference, but developers should not extend this class directly,\n * instead work with or extend the Entity implementations that are referenced in this section of the API documentation.\n *\n * Entities are instantiated by providing their base data, and an optional Array of Application instances which should\n * be automatically refreshed when the Entity experiences an update.\n *\n * @see {@link EntityCollection} The EntityCollection abstract class which contains Entity instances.\n * @see {@link Actor} The Actor Entity.\n * @see {@link Combat} The Combat Encounter Entity.\n * @see {@link Folder} The Folder Entity.\n * @see {@link Item} The Item Entity.\n * @see {@link JournalEntry} The Journal Entry Entity.\n * @see {@link ChatMessage} The Chat Message Entity.\n * @see {@link Playlist} The Audio Playlist Entity.\n * @see {@link Scene} The Scene Entity.\n * @see {@link RollTable} The Rollable Table Entity.\n * @see {@link User} The User Entity.\n * @see {@link Compendium} The Compendium which may contain Entities in a compendium pack.\n *\n * @typeParam D  - The type of the `Entity`s `_data` field. It should extend Entity.Data\n * @typeParam PD - The type of `Entity`s `data` field after `prepareData` has been called. It should extend `D`.\n *\n * @example\n * ```typescript\n * let actorData = {name: \"John Doe\", type: \"character\", img: \"icons/svg/mystery-man.svg\"}\n * let actor = new Actor(actorData)\n * ```\n */\ndeclare abstract class Entity<D extends Entity.Data = Entity.Data, PD extends D = D> {\n  /**\n   * @param data    - The data Object with which to create the Entity\n   * @param options - Additional options which modify the created Entity behavior\n   */\n  constructor(data?: DeepPartial<D>, options?: Entity.CreateOptions);\n\n  /**\n   * The original source data for the Entity provided upon initialization.\n   * This reflects the database state of the Entity before any transformations are applied.\n   * @defaultValue `{}`\n   */\n  _data: D;\n\n  /**\n   * The effective data for the Entity.\n   * This data object may have transformations applied to it.\n   * @defaultValue `this._data`\n   */\n  data: PD;\n\n  /**\n   * The options object that was used to configure the Entity upon initialization.\n   * @defaultValue `{}`\n   */\n  options: Entity.CreateOptions;\n\n  /**\n   * A collection of Application instances which should be re- rendered whenever this Entity experiences an update to\n   * its data. The keys of this object are the application ids and the values are Application instances. Each\n   * Application in this object will have its render method called by {@link Entity#render}.\n   * @see Entity#render\n   * @defaultValue `{}`\n   */\n  apps: Application[];\n\n  /**\n   * The Entity may optionally belong to a parent Compendium pack. If so this attribute will contain a reference\n   * to that Compendium object. Otherwise null.\n   * @defaultValue `null`\n   */\n  compendium: Compendium | null;\n\n  /**\n   * Safely Initialize data structure for the Entity.\n   * Errors that occur here should be captured and logged, but should not break construction of the Entity instance.\n   */\n  protected _initialize(): void;\n\n  /**\n   * Configure the attributes of this Entity class\n   * @param baseEntity - The parent class which directly inherits from the Entity interface.\n   * @param collection - The Collection instance to which Entities of this type belong.\n   * @param embeddedEntities - The names of any Embedded Entities within the Entity data structure.\n   *\n   * @remarks This method is abstract on Entity.\n   */\n  static get config(): Entity.Config;\n\n  /**\n   * A Universally Unique Identifier (uuid) for this Entity instance\n   */\n  get uuid(): string;\n\n  /**\n   * Return a string which represents a dynamic link to this Entity.\n   */\n  get link(): string;\n\n  /**\n   * Prepare data for the Entity whenever the instance is first created or later updated.\n   * This method can be used to derive any internal attributes which are computed in a formulaic manner.\n   * For example, in a d20 system - computing an ability modifier based on the value of that ability score.\n   */\n  prepareData(): PD | void;\n\n  /**\n   * Prepare Embedded Entities which exist within this parent Entity.\n   * For example, in the case of an Actor, this method is responsible for preparing the Owned Items the Actor contains.\n   * @remarks\n   * This is abstract on Entity and needs to be implemented, when the Entity subclass includes embedded Entities.\n   */\n  prepareEmbeddedEntities(): void;\n\n  /**\n   * Obtain a reference to the Array of source data within the data object for a certain Embedded Entity name\n   * @param embeddedName - The name of the Embedded Entity type\n   */\n  getEmbeddedCollection(embeddedName: string): any[]; // TODO maybe add general Entity data and return this here\n\n  /**\n   * Render all of the Application instances which are connected to this Entity by calling their respective\n   * {@link Application#render} methods.\n   * @param force   - Force rendering\n   *                  (default: `false`)\n   * @param context - Optional context\n   *                  (default: `{}`)\n   */\n  render(force?: boolean, context?: Entity.RenderOptions): void;\n\n  /**\n   * The class name of the base Entity type, for example \"Actor\". This is useful in cases where there is an inheritance\n   * chain. Many places throughout the framework rely upon the canonical entity name which may not always be equal\n   * to the class name. This property is available as both a static and instance method.\n   *\n   * @example\n   * ```typescript\n   * class Actor2ndGen extends Actor<Actor2ndGenData, Item2ndGen> {...}\n   * Actor2ndGen.entity // \"Actor\"\n   * ```\n   */\n  static get entity(): string;\n\n  get entity(): string;\n\n  /**\n   * A convenience accessor for the _id attribute of the Entity data object.\n   */\n  get id(): string;\n\n  get _id(): string;\n\n  /**\n   * A convenience accessor for the name attribute of the Entity data object\n   */\n  get name(): string;\n\n  /**\n   * A property which gets or creates a singleton instance of the sheet class used to render and edit data for this\n   * particular entity type.\n   *\n   * @example <caption>A subclass of the Actor entity</caption>\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use entity collections\";\n   * let actor = game.actors.get(actorId);\n   * if (actor === undefined) return;\n   * actor.sheet // ActorSheet\n   * ```\n   */\n  get sheet(): DocumentSheet<DocumentSheet.Options, DocumentSheet.Data<any>, any> | null;\n\n  /**\n   * Obtain a reference to the DocumentSheet implementation which should be used to render the Entity instance\n   * configuration sheet.\n   */\n  protected get _sheetClass(): ConstructorOf<FormApplication> | null;\n\n  /**\n   * Return a reference to the Folder which this Entity belongs to, if any.\n   *\n   * @example <caption>Entities may belong to Folders</caption>\n   * ```typescript\n   * if (game.folders === undefined) throw \"Too early to use entity collections\";\n   * let folder = game.folders.entities[0]\n   * let actor = await Actor.create({name: \"New Actor\", folder: folder.id})\n   * console.log(actor?.data.folder) // folder.id;\n   * console.log(actor?.folder) // folder;\n   * ```\n   */\n  get folder(): Folder | null | undefined;\n\n  /**\n   * Return the permission level that the current game User has over this Entity.\n   * See the CONST.ENTITY_PERMISSIONS object for an enumeration of these levels.\n   *\n   * @example\n   * ```typescript\n   * if (game.user === null) throw \"Too early to use game.user\";\n   * game.user.id // \"dkasjkkj23kjf\"\n   * entity.data.permission // {default: 1, \"dkasjkkj23kjf\": 2};\n   * entity.permission // 2\n   * ```\n   */\n  get permission(): foundry.CONST.EntityPermission;\n\n  /**\n   * A boolean indicator for whether or not the current game User has ownership rights for this Entity.\n   * This property has a setter which allows for ownership rights to be temporarily overridden on a per- instance basis.\n   */\n  get owner(): boolean;\n\n  /**\n   * A boolean indicator for whether or not the current game User has at least limited visibility for this Entity.\n   */\n  get visible(): boolean;\n\n  /**\n   * A boolean indicator for whether the current game user has ONLY limited visibility for this Entity.\n   * Note that a GM user's perspective of an Entity is never limited.\n   */\n  get limited(): boolean;\n\n  /**\n   * Return an array of User entities who have a certain permission level or greater to the Entity.\n   * @param permission - The permission level or level name to test\n   * @param exact      - Tests for an exact permission level match, by default this method tests for\n   *        an equal or greater permission level\n   * @returns An array of User entities who match the permission level\n   */\n  getUsers(permission: string | number, exact?: boolean): User[];\n\n  /**\n   * Test whether a provided User a specific permission level (or greater) over the Entity instance\n   * @param user       - The user to test for permission\n   * @param permission - The permission level or level name to test\n   * @param exact      - Tests for an exact permission level match, by default this method tests for an equal or greater permission level.\n   *\n   * @example <caption>Test whether a specific user has a certain permission</caption>\n   * ```typescript\n   * // These two are equivalent\n   * entity.hasPerm(game.user, \"OWNER\")\n   * entity.owner\n   * // These two are also equivalent\n   * entity.hasPerm(game.user, \"LIMITED\", true)\n   * entity.limited\n   * ```\n   */\n  hasPerm(user: User, permission: string | number, exact?: boolean): boolean;\n\n  /**\n   * Test whether a given User has permission to perform some action on this Entity\n   * @param user   - The User requesting creation\n   * @param action - The attempted action\n   * @param target - The targeted Entity\n   */\n  static can(user: User, action: string, target: Entity): boolean;\n\n  /**\n   * Test whether a given User has permission to perform some action on this Entity\n   * @param user   - The User to test\n   * @param action - The name of the action\n   * @remarks\n   * args is untyped because of a mismatch between most entities and User that is likely to be fixed in Foundry 0.8.x\n   *\n   */\n  can(...args: any): boolean;\n  // TODO: This is intentionally untyped. This is a known issue that will likely be fixed in 0.8.x\n\n  /**\n   * Test for whether this Entity can be owned by any non-gamemaster player.\n   */\n  get hasPlayerOwner(): boolean;\n\n  /**\n   * Activate the Socket event listeners used to receive responses from events which modify database documents\n   * @param socket - The active game socket\n   */\n  static activateSocketListeners(socket: io.Socket): void;\n\n  /**\n   * Create one or multiple new entities using provided input data.\n   * Data may be provided as a single object to create one Entity, or as an Array of Objects.\n   * Entities may be temporary (unsaved to the database) by passing the temporary option as true.\n   *\n   * @param data    - A Data object or array of Data\n   * @param options - Additional options which customize the creation workflow\n   *\n   * @example\n   * ```typescript\n   * const data = {name: \"New Entity\", type: \"character\", img: \"path/to/profile.jpg\"};\n   * const created: Actor | null = await Actor.create(data); // Returns one Entity, saved to the database\n   * const temp: Actor | null = await Actor.create(data, {temporary: true}); // Not saved to the database\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const data = [{name: \"Tim\", type: \"npc\"}, {name: \"Tom\", type: \"npc\"}];\n   * const created: Actor[] | Actor | null = await Actor.create(data); // Returns an Array of Entities, saved to the database\n   * const created: Actor[] | Actor | null = await Actor.create(data, {temporary: true}); // Not saved to the database\n   * ```\n   */\n  static create<T extends Entity, U>(\n    this: ConstructorOf<T>,\n    data: Expanded<U> extends DeepPartial<T['_data']> ? U : DeepPartial<T['_data']>,\n    options?: Entity.CreateOptions\n  ): Promise<T | null>;\n  static create<T extends Entity, U>(\n    this: ConstructorOf<T>,\n    data: Expanded<U> extends DeepPartial<T['_data']> ? ReadonlyArray<U> : ReadonlyArray<DeepPartial<T['_data']>>,\n    options?: Entity.CreateOptions\n  ): Promise<T | T[] | null>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Entities are created\n   * @param request - The initial request\n   * @param result  - An Array of created Entity data\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleCreate<T extends Entity>(this: ConstructorOf<T>, { request, result, userId }: any): T[];\n\n  /**\n   * Entity- specific actions that should occur when the Entity is first created\n   */\n  protected _onCreate(data: PD, options: any, userId: string): void;\n\n  /**\n   * Update one or multiple existing entities using provided input data.\n   * Data may be provided as a single object to update one Entity, or as an Array of Objects.\n   *\n   * @param data    - A Data object or array of Data. Each element must contain the _id of an existing Entity.\n   * @param options - Additional options which customize the update workflow\n   *\n   * @example\n   * ```typescript\n   * const data = {_id: \"12ekjf43kj2312ds\", name: \"New Name\"}}\n   * const updated = await Actor.update(data) // Updated entity saved to the database\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const data = [{_id: \"12ekjf43kj2312ds\", name: \"New Name 1\"}, {_id: \"kj549dk48k34jk34\", name: \"New Name 2\"}]}\n   * const updated = await Actor.update(data); // Returns an Array of Entities, updated in the database\n   * ```\n   */\n  static update<T extends Entity, U>(\n    this: ConstructorOf<T>,\n    data: Expanded<U> extends DeepPartial<T['_data']> ? U & { _id: string } : DeepPartial<T['_data']> & { _id: string },\n    options?: Entity.UpdateOptions\n  ): Promise<T | []>;\n  static update<T extends Entity, U>(\n    this: ConstructorOf<T>,\n    data: Expanded<U> extends DeepPartial<T['_data']>\n      ? ReadonlyArray<U & { _id: string }>\n      : ReadonlyArray<DeepPartial<T['_data']> & { _id: string }>,\n    options?: Entity.UpdateOptions\n  ): Promise<T | T[]>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Entities are updated\n   * @param request - The initial request\n   * @param result  - An Array of updated Entity data\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleUpdate<T extends Entity>(this: ConstructorOf<T>, { request, result, userId }: any): T[];\n\n  /**\n   * Entity-specific actions that should occur when the Entity is updated\n   */\n  protected _onUpdate(data: DeepPartial<D>, options: Entity.UpdateOptions, userId: string): void;\n\n  /**\n   * Update the current Entity using provided input data.\n   * Data must be provided as a single object which updates the Entity data.\n   * @see Entity.update\n   *\n   * @param data    - A Data object which updates the Entity\n   * @param options - Additional options which customize the update workflow\n   */\n  update<U>(data: Expanded<U> extends DeepPartial<D> ? U : never, options?: Entity.UpdateOptions): Promise<this>;\n  update(data: DeepPartial<D>, options?: Entity.UpdateOptions): Promise<this>;\n\n  /**\n   * Delete one or multiple existing entities using provided ids.\n   * The target ids may be a single string or an Array of strings.\n   *\n   * @param data    - A single id or Array of ids\n   * @param options - Additional options which customize the deletion workflow\n   *\n   *\n   * @example\n   * ```typescript\n   * const id = \"12ekjf43kj2312ds\"\n   * const deleted = await Entity.delete(id) // A single deleted entity from the database\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const ids = [\"12ekjf43kj2312ds\", \"kj549dk48k34jk34\"]\n   * const deleted = await Entity.delete(ids) // Returns an Array of deleted Entities\n   * ```\n   */\n  static delete<T extends Entity>(\n    this: ConstructorOf<T>,\n    data: string,\n    options?: Entity.DeleteOptions\n  ): Promise<T | null>;\n  static delete<T extends Entity>(\n    this: ConstructorOf<T>,\n    data: ReadonlyArray<string>,\n    options?: Entity.DeleteOptions\n  ): Promise<T | T[] | null>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Entities are deleted\n   * @param request - The initial request\n   * @param result  - An Array of deleted Entity ids\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleDelete<T extends Entity>(this: ConstructorOf<T>, { request, result, userId }: any): T[];\n\n  /**\n   * Entity- specific actions that should occur when the Entity is deleted\n   */\n  protected _onDelete(options: Entity.DeleteOptions, userId: string): void;\n\n  /**\n   * Delete the current Entity.\n   * @see Entity.delete\n   *\n   * @param options - Options which customize the deletion workflow\n   */\n  delete(options?: Entity.DeleteOptions): Promise<this>;\n\n  /**\n   * Get an Embedded Entity by it's id from a named collection in the parent Entity.\n   *\n   * @param embeddedName - The name of the Embedded Entity type to retrieve\n   * @param id           - The numeric ID of the child to retrieve\n   * @param strict       - Throw an Error if the requested id does not exist, otherwise return null. Default false.\n   */\n  getEmbeddedEntity(embeddedName: string, id: string, { strict }?: { strict?: boolean }): any;\n\n  /**\n   * Create one or multiple EmbeddedEntities within this parent Entity.\n   * Data may be provided as a single Object to create one EmbeddedEntity or as an Array of Objects to create many.\n   * Entities may be temporary (unsaved to the database) by passing the temporary option as true.\n   *\n   * @param embeddedName - The name of the Embedded Entity class to create\n   * @param data         - A Data object or an Array of Data objects to create\n   * @param options      - Additional creation options which modify the request\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === null) return;\n   * const data = {name: \"Magic Sword\", type: \"weapon\", img: \"path/to/icon.png\"};\n   * const created = await actor.createEmbeddedEntity(\"OwnedItem\", data); // Returns one EmbeddedEntity, saved to the Actor\n   * const temp = await actor.createEmbeddedEntity(\"OwnedItem\", data, {temporary: true}); // Not saved to the Actor\n   * ```\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === null) return;\n   * const data = [{name: \"Mace of Crushing\", type: \"weapon\"}, {name: \"Shield of Defense\", type: \"armor\"}];\n   * const created = await actor.createEmbeddedEntity(\"OwnedItem\", data); // Returns an Array of EmbeddedEntities, saved to the Actor\n   * const temp = await actor.createEmbeddedEntity(\"OwnedItem\", data, {temporary: true}); // Not saved to the Actor\n   * ```\n   */\n  createEmbeddedEntity(embeddedName: string, data: any, options?: Entity.CreateOptions): Promise<any>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Embedded Entities are created\n   * @param request - The initial request\n   * @param result  - An Array of created Entity data\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleCreateEmbeddedEntity({ request, result, userId }: any): any[];\n\n  /**\n   * Handle Embedded Entity creation within this Entity with specific callback steps.\n   * This function is triggered once per EmbeddedEntity which is updated.\n   * It therefore may run multiple times per creation workflow.\n   * Any steps defined here should run on a per- EmbeddedEntity basis.\n   * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()\n   */\n  protected _onCreateEmbeddedEntity(embeddedName: string, child: any, options: any, userId: string): void;\n\n  /**\n   * Update one or multiple existing entities using provided input data.\n   * Data may be provided as a single object to update one Entity, or as an Array of Objects.\n   *\n   * @param embeddedName - The name of the Embedded Entity class to create\n   * @param data         - A Data object or array of Data. Each element must contain the _id of an existing Entity.\n   * @param options      - Additional options which customize the update workflow\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === undefined) return;\n   * const item = actor.data.items.find(i => i.name === \"magic sword\");\n   * if (item === undefined) return;\n   * const update = {_id: item._id, name: \"magic sword +1\"};\n   * const updated = await actor.updateEmbeddedEntity(\"owneditem\", update); // updates one embeddedentity\n   * ```\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === undefined) return;\n   * const weapons = actor.data.items.filter(i => i.type === \"weapon\");\n   * const updates = weapons.map(i => {\n   *   return {_id: i._id, name: i.name + \"+1\"};\n   * });\n   * const updated = await actor.updateEmbeddedEntity(\"OwnedItem\", updates); // Updates multiple EmbeddedEntity objects\n   * ```\n   */\n  updateEmbeddedEntity(embeddedName: string, data: any, options?: Entity.UpdateOptions): Promise<any>;\n  updateEmbeddedEntity(embeddedName: string, data: any[], options?: Entity.UpdateOptions): Promise<any[]>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Embedded Entities are updated\n   * @param request - The initial request\n   * @param result  - An Array of updated Entity data\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleUpdateEmbeddedEntity({ request, result, userId }: any): any[];\n\n  /**\n   * Handle Embedded Entity updates within this Entity with specific callback steps.\n   * This function is triggered once per EmbeddedEntity which is updated.\n   * It therefore may run multiple times per creation workflow.\n   * Any steps defined here should run on a per- EmbeddedEntity basis.\n   * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()\n   */\n  protected _onUpdateEmbeddedEntity(\n    embeddedName: string,\n    child: any,\n    updateData: any,\n    options: any,\n    userId: string\n  ): void;\n\n  /**\n   * Delete one or multiple existing EmbeddedEntity objects using provided input data.\n   * Data may be provided as a single id to delete one object or as an Array of string ids.\n   *\n   * @param embeddedName - The name of the Embedded Entity class to create\n   * @param data         - A Data object or array of Data. Each element must contain the _id of an existing Entity.\n   * @param options      - Additional options which customize the update workflow\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === undefined) return;\n   * const item = actor.data.items.find(i => i.name === \"Magic Sword\");\n   * if (item === undefined) return;\n   * const deleted = await actor.deleteEmbeddedEntity(\"OwnedItem\", item._id); // Deletes one EmbeddedEntity\n   * ```\n   *\n   * @example\n   * ```typescript\n   * if (game.actors === undefined) throw \"Too early to use an enitity collection\";\n   * const actor = game.actors.get(\"dfv934kj23lk6h9k\");\n   * if (actor === undefined) return;\n   * const weapons = actor.data.items.filter(i => i.type === \"weapon\");\n   * const deletions = weapons.map(i => i._id);\n   * const deleted = await actor.deleteEmbeddedEntity(\"OwnedItem\", deletions); // Deletes multiple EmbeddedEntity objects\n   * ```\n   */\n  deleteEmbeddedEntity(embeddedName: string, data: any, options?: Entity.DeleteOptions): Promise<any | any[]>;\n\n  /**\n   * Handle a SocketResponse from the server when one or multiple Embedded Entities are deleted\n   * @param request - The initial request\n   * @param result  - An Array of deleted EmbeddedEntity ids\n   * @param userId  - The id of the requesting User\n   */\n  protected static _handleDeleteEmbeddedEntity({ request, result, userId }: any): any[];\n\n  /**\n   * Handle Embedded Entity deletion within this Entity with specific callback steps.\n   * This function is triggered once per EmbeddedEntity which is updated.\n   * It therefore may run multiple times per creation workflow.\n   * Any steps defined here should run on a per- EmbeddedEntity basis.\n   * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()\n   */\n  protected _onDeleteEmbeddedEntity(embeddedName: string, child: any, options: any, userId: string): void;\n\n  /**\n   * A generic helper since we take the same actions for every type of Embedded Entity update\n   * Unlike the specific _onCreate, _onUpdate, and _onDelete methods this only runs once per updated batch\n   */\n  protected _onModifyEmbeddedEntity(\n    embeddedName: string,\n    changes: any[],\n    options: any,\n    userId: string,\n    context?: any\n  ): void;\n\n  /**\n   * Get the value of a \"flag\" for this Entity\n   * See the setFlag method for more details on flags\n   *\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   */\n  getFlag(scope: string, key: string): unknown;\n\n  /**\n   * Assign a \"flag\" to this Entity.\n   * Flags represent key- value type data which can be used to store flexible or arbitrary data required by either\n   * the core software, game systems, or user- created modules.\n   *\n   * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.\n   *\n   * Flags set by the core software use the \"core\" scope.\n   * Flags set by game systems or modules should use the canonical name attribute for the module\n   * Flags set by an individual world should \"world\" as the scope.\n   *\n   * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.\n   *\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   * @param value - The flag value\n   *\n   */\n  setFlag(scope: string, key: string, value: unknown): Promise<this>;\n\n  /**\n   * Remove a flag assigned to the Entity\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   */\n  unsetFlag(scope: string, key: string): Promise<this>;\n\n  /**\n   * Sort this Entity relative a target by providing the target, an Array of siblings and other options.\n   * If the Entity has an rendered sheet, record the sort change as part of a form submission\n   * See SortingHelper.performIntegerSort for more details\n   */\n  sortRelative({\n    target,\n    siblings,\n    sortKey,\n    sortBefore,\n    updateData\n  }: {\n    target?: Entity | null;\n    siblings?: Entity[];\n    sortKey?: string;\n    sortBefore?: boolean;\n    updateData?: any;\n  }): Promise<void>;\n\n  /**\n   * Clone an Entity, creating a new Entity using the current data as well as provided creation overrides.\n   *\n   * @param createData - Additional data which overrides current Entity data at the time of creation\n   * @param options - Additional creation options passed to the Entity.create method\n   * @returns A Promise which resolves to the created clone Entity\n   */\n  clone(createData?: DeepPartial<D>, options?: Entity.CreateOptions): Promise<this>;\n\n  /**\n   * Serializing an Entity should simply serialize it's inner data, not the entire instance\n   */\n  toJSON(): D;\n\n  /**\n   * Export entity data to a JSON file which can be saved by the client and later imported into a different session\n   */\n  exportToJSON(): void;\n\n  /**\n   * A helper function to handle obtaining the dropped Entity data from a dropped event. Entity drop data could have:\n   * 1. A compendium pack and entry id\n   * 2. A World Entity _id\n   * 3. A data object explicitly provided\n   *\n   * @param data - The data object extracted from a DataTransfer event\n   */\n  static fromDropData<\n    T extends Entity,\n    U extends { data: DeepPartial<T['_data']> } | { pack: string } | { id: string }\n  >(\n    this: ConstructorOf<T>,\n    data: U\n  ): U extends { data: DeepPartial<T['_data']> }\n    ? Promise<T>\n    : U extends { id: string }\n    ? Promise<T | null>\n    : Promise<T | undefined | null>;\n\n  /**\n   * Import data and update this entity\n   * @param json - JSON data string\n   */\n  importFromJSON(json: string): Promise<this>;\n\n  /**\n   * Render an import dialog for updating the data related to this Entity through an exported JSON file\n   */\n  importFromJSONDialog(): Promise<void>;\n\n  /**\n   * Transform the Entity data to be stored in a Compendium pack.\n   * Remove any features of the data which are world- specific.\n   * This function is asynchronous in case any complex operations are required prior to exporting.\n   */\n  toCompendium(): Promise<Omit<foundry.utils.Duplicated<D>, '_id' | 'permission' | 'folder' | 'sort' | 'active'>>;\n\n  /**\n   * Provide a Dialog form to create a new Entity of this type.\n   * Choose a name and a type from a select menu of types.\n   * @param data - Initial data with which to populate the creation form\n   * @param options - Initial positioning and sizing options for the dialog form\n   */\n  static createDialog(\n    data?: { name?: string; folder?: string; type?: string },\n    options?: Partial<Dialog.Options>\n  ): Promise<Entity>;\n}\n\ndeclare namespace Entity {\n  /**\n   * Common {@link Entity} create options\n   */\n  interface CreateOptions {\n    [propName: string]: any;\n\n    /**\n     * A reference to the Compendium pack from which this Entity was drawn.\n     */\n    compendium?: Compendium;\n\n    /**\n     * Block the dispatch of preCreate hooks for this operation.\n     * @defaultValue `false`\n     */\n    noHook?: boolean;\n\n    /**\n     * Display the sheet for the created entity once it is created.\n     * @defaultValue `false`\n     */\n    renderSheet?: boolean;\n\n    /**\n     * Create a temporary entity which is not saved to the world database.\n     * @defaultValue `false`\n     */\n    temporary?: boolean;\n  }\n\n  /**\n   * Common {@link Entity} delete options\n   */\n  interface DeleteOptions {\n    [propName: string]: any;\n\n    /**\n     * Block the dispatch of preDelete hooks for this operation.\n     * @defaultValue `false`\n     */\n    noHook?: boolean;\n  }\n\n  /**\n   * Common {@link Entity} update options\n   */\n  interface UpdateOptions {\n    [propName: string]: any;\n\n    /**\n     * Difference the provided data against the current to eliminate unnecessary\n     * changes.\n     * @defaultValue `true`\n     */\n    diff?: boolean;\n\n    /**\n     * Block the dispatch of preUpdate hooks for this operation.\n     * @defaultValue `false`\n     */\n    noHook?: boolean;\n  }\n\n  interface Config<E extends Entity = Entity> {\n    baseEntity: ConstructorOf<E>;\n    embeddedEntities?: {\n      [embedType: string]: string;\n    };\n    label?: string;\n    permissions?: {\n      [propName: string]: string;\n    };\n  }\n\n  interface Permission {\n    [userId: string]: number;\n    default: number;\n  }\n\n  /**\n   * Data structure common to all entities\n   */\n  interface Data {\n    /**\n     * The id assigned by the database\n     */\n    _id: string;\n\n    /**\n     * Flags for arbitrary data from modules &c.\n     */\n    flags: Record<string, unknown>;\n\n    folder?: string;\n\n    name?: string;\n\n    permission?: Permission;\n\n    type?: any;\n  }\n\n  interface RenderOptions extends Application.RenderOptions {\n    data: {\n      permission: unknown;\n    };\n  }\n}\n"
    ]
  