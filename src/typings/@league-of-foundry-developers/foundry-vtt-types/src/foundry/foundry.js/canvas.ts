
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\canvas.d.ts",
      "/**\n * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js\n * library. The canvas is comprised of an ordered sequence of layers which define rendering groups and collections of\n * objects that are drawn on the canvas itself.\n *\n * @see {@link CanvasLayer} An abstract class for all Canvas layers.\n * @see {@link PlaceablesLayer} An abstract class for Canvas Layers which contain Placeable Objects.\n * @see {@link PlaceableObject} An abstract class for objects which are placed into the Scene and drawn on the canvas.\n *\n * @example <caption>Example Canvas commands</caption>\n * ```typescript\n * canvas.ready; // Is the canvas ready for use?\n * canvas.scene; // The currently viewed Scene entity.\n * canvas.dimensions; // The dimensions of the current Scene.\n * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).\n * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.\n * canvas.recenter(); // Re-center the canvas on the currently controlled Token.\n * ```\n */\ndeclare class Canvas {\n  constructor();\n\n  protected _dragDrop: DragDrop;\n\n  app: PIXI.Application;\n\n  stage: PIXI.Container;\n\n  hud: HeadsUpDisplay;\n\n  background: any; // TODO: BackgroundLayer\n\n  tiles: any; //TODO: TilesLayer\n\n  drawings: any; //TODO: DrawingsLayer\n\n  grid: GridLayer;\n\n  walls: any; //TODO: WallsLayer\n\n  templates: any; //TODO: TemplateLayer\n\n  notes: any; //TODO: NotesLayer\n\n  tokens: TokenLayer;\n\n  lighting: LightingLayer;\n\n  sounds: any; //TODO: SoundsLayer\n\n  sight: SightLayer;\n\n  effects: any; //TODO: EffectsLayer\n\n  controls: any; //TODO: ControlsLayer\n\n  /**\n   * @defaultValue `null`\n   */\n  id: string | null;\n\n  /**\n   * @defaultValue `null`\n   */\n  scene: Scene | null;\n\n  /**\n   * @defaultValue `null`\n   */\n  dimensions: Canvas.Dimensions | null;\n\n  /**\n   * Track the timestamp of the last stage zoom operation\n   * @defaultValue `0`\n   */\n  protected _zoomTime: number;\n\n  /**\n   * Track the last automatic pan time to throttle\n   * @defaultValue `0`\n   */\n  protected _panTime: number;\n\n  /**\n   * An object of data which is temporarily cached to be reloaded after the canvas is drawn\n   * @defaultValue `{ layer: 'TokenLayer' }`\n   */\n  protected _reload: { layer: string };\n\n  /**\n   * The singleton interaction manager instance which handles mouse workflows on the Canvas\n   * @defaultValue `null`\n   */\n  mouseInteractionManager: MouseInteractionManager<this['stage']> | null;\n\n  /**\n   * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.\n   * @defaultValue `false`\n   */\n  ready: boolean;\n\n  /**\n   * An Array of pending canvas operations which should trigger on the next re-paint\n   */\n  pendingOperations: Array<[(args: any[]) => void, any, any[]]>;\n\n  /**\n   * A Set of unique pending operation names to ensure operations are only performed once\n   */\n  protected _pendingOperationNames: Set<string>;\n\n  /**\n   * Create the layers of the game Canvas.\n   * @param stage - The primary canvas stage\n   */\n  protected _createLayers(stage: PIXI.Container): void;\n\n  /**\n   * A mapping of named CanvasLayers.\n   * This mapping is defined in the order that layers must be drawn.\n   */\n  static get layers(): {\n    background: any; // TODO: ConstructorOf<BackgroundLayer>\n    tiles: any; // TODO: ConstructorOf<TilesLayer>\n    drawings: any; // TODO: ConstructorOf<DrawingsLayer>\n    grid: ConstructorOf<GridLayer>;\n    walls: any; // TODO: ConstructorOf<WallsLayer>\n    templates: any; // TODO: ConstructorOf<TemplateLayer>\n    notes: any; // TODO: ConstructorOf<NotesLayer>\n    tokens: ConstructorOf<TokenLayer>;\n    lighting: ConstructorOf<LightingLayer>;\n    sounds: any; // TODO: ConstructorOf<SoundsLayer>\n    sight: ConstructorOf<SightLayer>;\n    effects: any; // TODO: ConstructorOf<EffectsLayer>\n    controls: any; // TODO: ConstructorOf<ControlsLayer>\n  } & Partial<Record<string, ConstructorOf<CanvasLayer>>>;\n\n  /**\n   * An Array of all CanvasLayer instances which are active on the Canvas board\n   */\n  get layers(): CanvasLayer[];\n\n  /**\n   * Return a reference to the active Canvas Layer\n   */\n  get activeLayer(): CanvasLayer | null;\n\n  /**\n   * When re-drawing the canvas, first tear down or discontinue some existing processes\n   */\n  tearDown(): Promise<void>;\n\n  /**\n   * Draw the game canvas.\n   * @returns A Promise which resolves once the Canvas is fully drawn\n   */\n  draw(scene?: Scene): Promise<this>;\n\n  /**\n   * Get the canvas active dimensions based on the size of the scene's map.\n   * We expand the image size by a factor of 1.5 and round to the nearest 2x grid size.\n   * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.\n   * @param data - The scene dimensions data being established\n   */\n  static getDimensions(data: Canvas.DimensionsData): Canvas.Dimensions;\n\n  /**\n   * Once the canvas is drawn, initialize control, visibility, and audio states\n   */\n  protected _initialize(): Promise<void>;\n\n  /**\n   * Initialize all lighting, vision, and sound sources for the Scene.\n   */\n  initializeSources(): void;\n\n  /**\n   * Initialize the starting view of the canvas stage\n   * If we are re-drawing a scene which was previously rendered, restore the prior view position\n   * Otherwise set the view to the top-left corner of the scene at standard scale\n   */\n  protected _initializeCanvasPosition(): void;\n\n  /**\n   * Initialize a CanvasLayer in the activation state\n   */\n  protected _initializeCanvasLayer(): void;\n\n  /**\n   * Initialize a token or set of tokens which should be controlled.\n   * Restore controlled and targeted tokens from before the re-draw.\n   */\n  protected _initializeTokenControl(): void;\n\n  /**\n   * Get a reference to the a specific CanvasLayer by it's name\n   * @param layerName - The name of the canvas layer to get\n   */\n  getLayer(layerName: string): CanvasLayer | null;\n\n  /**\n   * Given an embedded object name, get the canvas layer for that object\n   */\n  protected getLayerByEmbeddedName<T extends string>(\n    embeddedName: T\n  ): T extends keyof Canvas.EmbeddedEntityNameToLayerMap ? Canvas.EmbeddedEntityNameToLayerMap[T] : null;\n\n  /**\n   * Pan the canvas to a certain \\{x,y\\} coordinate and a certain zoom level\n   * @param x     - The x-coordinate of the pan destination\n   * @param y     - The y-coordinate of the pan destination\n   * @param scale - The zoom level (max of CONFIG.Canvas.maxZoom) of the action\n   */\n  pan({ x, y, scale }?: Canvas.ViewPan): void;\n\n  /**\n   * Animate panning the canvas to a certain destination coordinate and zoom scale\n   * Customize the animation speed with additional options\n   * Returns a Promise which is resolved once the animation has completed\n   *\n   * @param x        - The destination x-coordinate\n   * @param y        - The destination y-coordinate\n   * @param scale    - The destination zoom scale\n   * @param duration - The total duration of the animation in milliseconds; used if speed is not set\n   * @param speed    - The speed of animation in pixels per second; overrides duration if set\n   * @returns A Promise which resolves once the animation has been completed\n   */\n  animatePan({ x, y, scale, duration, speed }?: Canvas.AnimatedViewPan): Promise<void>;\n\n  /**\n   * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter\n   * @param x     - The requested x-coordinate\n   * @param y     - The requested y-coordinate\n   * @param scale - The requested scale\n   * @returns The allowed scale\n   */\n  protected _constrainView({ x, y, scale }: Canvas.ViewPan): Canvas.View;\n\n  /**\n   * Update the blur strength depending on the scale of the canvas stage\n   */\n  protected _updateBlur(scale: number): void;\n\n  /**\n   * Recenter the canvas\n   * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window\n   */\n  recenter(coordinates?: Canvas.ViewPan | null): void;\n\n  /**\n   * Attach event listeners to the game canvas to handle click and interaction events\n   */\n  protected _addListeners(): void;\n\n  /**\n   * Handle left mouse-click events occurring on the Canvas stage or its active Layer.\n   * @see {@link MouseInteractionManager#_handleClickLeft}\n   */\n  protected _onClickLeft(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle double left-click events occurring on the Canvas stage.\n   * @see {@link MouseInteractionManager#_handleClickLeft2}\n   */\n  protected _onClickLeft2(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.\n   * @see {@link MouseInteractionManager#_handleDragStart}\n   */\n  protected _onDragLeftStart(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle mouse movement events occurring on the Canvas stage or it's active layer\n   * @see {@link MouseInteractionManager#_handleDragMove}\n   */\n  protected _onDragLeftMove(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.\n   * @see {@link MouseInteractionManager#_handleDragDrop}\n   */\n  protected _onDragLeftDrop(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle the cancellation of a left-mouse drag workflow\n   * @see {@link MouseInteractionManager#_handleDragCancel}\n   */\n  protected _onDragLeftCancel(event: PointerEvent): void;\n\n  /**\n   * Handle right mouse-click events occurring on the Canvas stage or it's active layer\n   * @see {@link MouseInteractionManager#_handleClickRight}\n   */\n  protected _onClickRight(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle right-mouse drag events occuring on the Canvas stage or an active Layer\n   * @see {@link MouseInteractionManager#_handleDragMove}\n   */\n  protected _onDragRightMove(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Handle the conclusion of a right-mouse drag workflow the Canvas stage.\n   * @see {@link MouseInteractionManager#_handleDragDrop}\n   * @param event - (unused)\n   */\n  protected _onDragRightDrop(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Determine selection coordinate rectangle during a mouse-drag workflow\n   */\n  protected _onDragSelect(event: PIXI.InteractionEvent): void;\n\n  /**\n   * Pan the canvas view when the cursor position gets close to the edge of the frame\n   * @param event - The originating mouse movement event\n   */\n  protected _onDragCanvasPan(event: MouseEvent): Promise<void> | void;\n\n  /**\n   * Handle window resizing with the dimensions of the window viewport change\n   * @param event - The Window resize event\n   *                (default: `null`)\n   */\n  protected _onResize(event?: UIEvent | null): void;\n\n  /**\n   * Handle mousewheel events which adjust the scale of the canvas\n   * @param event - The mousewheel event that zooms the canvas\n   */\n  protected _onMouseWheel(event: WheelEvent): void;\n\n  /**\n   * Event handler for the drop portion of a drag-and-drop event.\n   */\n  protected _onDrop(event: DragEvent): boolean;\n\n  /**\n   * Add a pending canvas operation that should fire once the socket handling workflow concludes.\n   * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.\n   * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.\n   * @param name  - A unique name for the pending operation, conventionally Class.method\n   * @param fn    - The unbound function to execute later\n   * @param scope - The scope to which the method should be bound when called\n   * @param args  - Arbitrary arguments to pass to the method when called\n   */\n  addPendingOperation<S = any, A = any[]>(name: string, fn: (this: S, args: A) => void, scope: S, args: A): void;\n\n  /* -------------------------------------------- */\n\n  /**\n   * Fire all pending functions that are registered in the pending operations queue and empty it.\n   */\n  triggerPendingOperations(): void;\n}\n\ndeclare namespace Canvas {\n  interface Dimensions {\n    sceneWidth: number;\n    sceneHeight: number;\n    size: number;\n    distance: number;\n    shiftX: number;\n    shiftY: number;\n    ratio: number;\n    paddingX: number;\n    width: number;\n    paddingY: number;\n    height: number;\n    rect: PIXI.Rectangle;\n    sceneRect: PIXI.Rectangle;\n  }\n\n  interface DimensionsData {\n    width?: number | null;\n    height?: number | null;\n    grid: number;\n    gridDistance: number;\n    padding: number;\n    shiftX: number;\n    shiftY: number;\n  }\n\n  interface DropPosition {\n    x: number;\n    y: number;\n  }\n\n  interface ViewPan {\n    x?: number | null;\n    y?: number | null;\n    scale?: number | null;\n  }\n\n  interface AnimatedViewPan extends ViewPan {\n    duration?: number | null;\n    speed?: number | null;\n  }\n\n  interface View {\n    x: number;\n    y: number;\n    scale: number;\n  }\n\n  interface EmbeddedEntityNameToLayerMap {\n    AmbientLight: Canvas['lighting'];\n    AmbientSound: Canvas['sounds'];\n    Drawing: Canvas['drawings'];\n    Note: Canvas['notes'];\n    MeasuredTemplate: Canvas['templates'];\n    Tile: Canvas['tiles'];\n    Token: Canvas['tokens'];\n    Wall: Canvas['walls'];\n  }\n}\n"
    ]
  