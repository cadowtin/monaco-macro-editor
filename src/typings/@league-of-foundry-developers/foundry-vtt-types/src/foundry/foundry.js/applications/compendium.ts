
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\applications\\compendium.d.ts",
      "/**\n * The Compendium class provides an interface for interacting with compendium packs which are\n * collections of similar Entities which are stored outside of the world database but able to\n * be easily imported into an active session.\n *\n * When the game session is initialized, each available compendium pack is constructed and\n * added to the `game.packs`.\n *\n * Each Compendium is distinctly referenced using its canonical \"collection\" name which is a\n * unique string that contains the package name which provides the compendium as well as the\n * name of the pack within that package. For example, in the D&D5e system, the compendium pack\n * which provides the spells available within the SRD has the collection name \"dnd5e.spells\".\n *\n * @example\n * ```javascript\n * // Let's learn the collection names of all the compendium packs available within a game\n * game.packs.map(p => p.collection);\n *\n * // Suppose we are working with a particular pack named \"dnd5e.spells\"\n * const pack = game.packs.find(p => p.collection === \"dnd5e.spells\");\n *\n * // We can load the index of the pack which contains all entity IDs, names, and image icons\n * pack.getIndex().then(index => console.log(index));\n *\n * // We can find a specific entry in the compendium by its name\n * let entry = pack.index.find(e => e.name === \"Acid Splash\");\n *\n * // Given the entity ID of \"Acid Splash\" we can load the full Entity from the compendium\n * pack.getEntity(entry.id).then(spell => console.log(spell));\n * ```\n * @example\n * ```javascript\n * // We often may want to programmatically create new Compendium content\n * // Let's start by creating a custom spell as an Item instance\n * let itemData = {name: \"Custom Death Ray\", type: \"Spell\"};\n * let item = new Item(itemData);\n *\n * // Once we have an entity for our new Compendium entry we can import it, if the pack is unlocked\n * pack.importEntity(item);\n *\n * // When the entity is imported into the compendium it will be assigned a new ID, so let's find it\n * pack.getIndex().then(index => {\n *   let entry = index.find(e => e.name === itemData.name));\n *   console.log(entry);\n * });\n *\n * // If we decide to remove an entry from the compendium we can do that by the entry ID\n * pack.removeEntry(entry.id);\n * ```\n * @typeParam P - the type of the options object\n */\ndeclare class Compendium<P extends Application.Options = Application.Options> extends Application<P> {\n  /**\n   * @param metadata - The compendium metadata, an object provided by game.data\n   * @param options  - Application rendering options\n   */\n  constructor(metadata: Compendium['metadata'], options?: Partial<P>);\n\n  /**\n   * The compendium metadata which defines the compendium content and location\n   */\n  metadata: Compendium.Metadata;\n\n  /**\n   * Track whether the compendium pack is locked for editing\n   */\n  locked: boolean;\n\n  /**\n   * Track whether the compendium pack is private\n   * @defaultValue `false`\n   */\n  private: boolean;\n\n  /**\n   * The most recently retrieved index of the Compendium content\n   * This index is not guaranteed to be current - call getIndex() to reload the index\n   */\n  index: Compendium.IndexEntry[];\n\n  /** @override */\n  static get defaultOptions(): typeof Application['defaultOptions'];\n\n  /** @override */\n  getTitle(): string;\n\n  /**\n   * The canonical Compendium name - comprised of the originating package and the pack name\n   * @returns The canonical collection name\n   */\n  get collection(): string;\n\n  /**\n   * The Entity type which is allowed to be stored in this collection\n   */\n  get entity(): string;\n\n  /**\n   * A reference to the Entity class object contained within this Compendium pack\n   */\n  get cls(): ConstructorOf<Entity>;\n\n  /** @override */\n  getData(options: Application.RenderOptions): Promise<any>; // TODO\n\n  /** @override */\n  close(): Promise<void>;\n\n  /**\n   * Create a new Compendium pack using provided\n   * @param metadata - The compendium metadata used to create the new pack\n   * @param options  - Additional options which modify the Compendium creation request\n   */\n  static create(metadata: Compendium.Metadata, options?: Record<string, any>): Promise<Compendium>;\n\n  /**\n   * Assign configuration metadata settings to the compendium pack\n   * @param settings - The object of compendium settings to define\n   * @returns A Promise which resolves once the setting is updated\n   */\n  configure(settings?: Partial<Compendium.Settings>): Promise<Compendium.Settings>;\n\n  /**\n   * Delete a world Compendium pack\n   * This is only allowed for world-level packs by a GM user\n   */\n  delete(): Promise<this>;\n\n  /**\n   * Duplicate a compendium pack to the current World\n   */\n  duplicate({ label }?: { label?: string }): Promise<Compendium>;\n\n  /**\n   * Get the Compendium index\n   * Contains names, images and IDs of all data in the compendium\n   *\n   * @returns A Promise containing an index of all compendium entries\n   */\n  getIndex(): Promise<Compendium.IndexEntry[]>;\n\n  /**\n   * Get the complete set of content for this compendium, loading all entries in full\n   * Returns a Promise that resolves to an Array of entries\n   */\n  getContent(): Promise<Entity[]>;\n\n  /**\n   * Get a single Compendium entry as an Object\n   * @param entryId - The compendium entry ID to retrieve\n   *\n   * @returns A Promise containing the return entry data, or null\n   */\n  getEntry(entryId: string): Promise<any | null>; // TODO\n\n  /**\n   * Get a single Compendium entry as an Entity instance\n   * @param entryId - The compendium entry ID to load and instantiate\n   * @returns A Promise containing the returned Entity, if it exists, otherwise null\n   */\n  getEntity(entryId: string): Promise<Entity | null>;\n\n  /**\n   * Fully import the contents of a Compendium pack into a World folder.\n   * @param folderId   - An existing Folder _id to use.\n   *                     (default: `null`)\n   * @param folderName - A new Folder name to create.\n   *                     (default: `''`)\n   */\n  importAll({\n    folderId,\n    folderName\n  }: {\n    folderId?: string | null;\n    folderName?: string;\n  }): Promise<Entity | Entity[] | null>;\n\n  /**\n   * Cast entry data to an Entity class\n   */\n  protected _toEntity(entryData?: any): Entity; // TODO\n\n  /**\n   * Import a new Entity into a Compendium pack\n   * @param entity - The Entity instance you wish to import\n   * @returns A Promise which resolves to the created Entity once the operation is complete\n   */\n  importEntity(entity: Entity): Promise<Entity>;\n\n  /**\n   * Create a new Entity within this Compendium Pack using provided data\n   * @param data - Data with which to create the entry\n   * @returns A Promise which resolves to the created Entity once the operation is complete\n   */\n  createEntity(\n    data: Record<string, any> | Record<string, any>[],\n    options?: Record<string, any>\n  ): Promise<Entity | Entity[]>;\n\n  /**\n   * Update a single Compendium entry programmatically by providing new data with which to update\n   * @param data    - The incremental update with which to update the Entity. Must contain the _id\n   * @param options - Additional options which modify the update request\n   * @returns A Promise which resolves with the updated Entity once the operation is complete\n   */\n  updateEntity(data: any | any[], options?: Record<string, any> & { entity: Entity }): Promise<any[]>; // TODO\n\n  /**\n   * Delete a single Compendium entry by its provided _id\n   * @param id - The entry ID to delete\n   * @returns A Promise which resolves to the deleted entry ID once the operation is complete\n   */\n  deleteEntity(id: string | string[]): Promise<string[]>;\n\n  /**\n   * Request that a Compendium pack be migrated to the latest System data template\n   */\n  migrate(options: Record<string, unknown>): Promise<Compendium>;\n\n  /**\n   * Validate that the current user is able to modify content of this Compendium pack\n   * @param requireGM       - (default: `true`)\n   * @param requireUnlocked - (default: `true`)\n   */\n  protected _assertUserCanModify({\n    requireGM,\n    requireUnlocked\n  }?: {\n    requireGM?: boolean;\n    requireUnlocked?: boolean;\n  }): boolean;\n\n  /**\n   * Register event listeners for Compendium directories\n   */\n  activateListeners(html: JQuery): void;\n\n  /** @override */\n  protected _onSearchFilter(event: KeyboardEvent, query: string, rgx: RegExp, html: HTMLElement): void;\n\n  /**\n   * Handle opening a single compendium entry by invoking the configured entity class and its sheet\n   * @param entryId - The compendium ID of the entry to display\n   */\n  protected _onEntry(entryId: string): Promise<void>;\n\n  /** @override */\n  protected _canDragStart(selector: string | null): boolean;\n\n  /** @override */\n  protected _canDragDrop(selector: string | null): boolean;\n\n  /** @override */\n  protected _onDragStart(event: DragEvent): void;\n\n  /**\n   * Handle data being dropped into a Compendium pack\n   */\n  protected _onDrop(event: DragEvent): Promise<false | Entity>;\n\n  /**\n   * Render the ContextMenu which applies to each compendium entry\n   */\n  _contextMenu(html: JQuery): void;\n\n  static CONFIG_SETTING: 'compendiumConfiguration';\n}\n\ndeclare namespace Compendium {\n  interface IndexEntry {\n    _id: string;\n    name: string;\n    img?: string;\n  }\n\n  interface Metadata {\n    name: string;\n    label: string;\n    system?: string | string[];\n    module?: string;\n    path: string;\n    entity: 'Actor' | 'Item' | 'JournalEntry' | 'Macro' | 'Playlist' | 'RollTable' | 'Scene';\n    package: string;\n    absPath: string;\n  }\n\n  interface Data {\n    collection: string;\n    cssClass: string;\n    index: Array<IndexEntry & { img: string }>;\n  }\n\n  interface Settings {\n    private: boolean;\n    locked: boolean;\n  }\n}\n"
    ]
  